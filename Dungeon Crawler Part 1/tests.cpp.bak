#include <iostream>
#include "logic.h"

using std::cout, std::endl;

// TODO(student): Write unit tests for the functions in logic.h
//                You should end up with at least 500 lines of test code


//unit tests for loading map
void test_load(){

//unhappy test cases (should fail)

//Test case 1

	{
		int maxRow = 0;
		int maxCol = 0;
		Player player;
		char** level = loadLevel("example.txt", maxRow, maxCol, player);
		
		for (int row = 0; row < 5; row++) {
            delete[] level[row];
        }
        delete[] level;
	}
	
	{
		int maxRow = 0;
		int maxCol = 0;
		Player player;
		char** level = loadLevel("example2.txt", maxRow, maxCol, player);

	}

//Test case 2
	{
		int maxRow = 0;
		int maxCol = 0;
		Player player;
		char** level = loadLevel("example.txt", maxRow, maxCol, player);
		
		for (int row = 0; row < 5; row++) {
            delete[] level[row];
        }
        delete[] level;
	}
	
	{
		int maxRow = 0;
		int maxCol = 0;
		Player player;
		char** level = loadLevel("example3.txt", maxRow, maxCol, player);

	}
	
//Test case 3
	{
		int maxRow = 0;
		int maxCol = 0;
		Player player;
		char** level = loadLevel("example.txt", maxRow, maxCol, player);
		
		for (int row = 0; row < 5; row++) {
            delete[] level[row];
        }
        delete[] level;
	}
	
	{
		int maxRow = 0;
		int maxCol = 0;
		Player player;
		char** level = loadLevel("example4.txt", maxRow, maxCol, player);

	}
//Test case 4 (increasing size of map without changing dimensions)
	{
		int maxRow = 0;
		int maxCol = 0;
		Player player;
		char** level = loadLevel("example.txt", maxRow, maxCol, player);
		
		for (int row = 0; row < 5; row++) {
            delete[] level[row];
        }
        delete[] level;
	}
	
	{
		int maxRow = 0;
		int maxCol = 0;
		Player player;
		char** level = loadLevel("example5.txt", maxRow, maxCol, player);

	}
	
//Test case 5 (special characters)
	{
		int maxRow = 0;
		int maxCol = 0;
		Player player;
		char** level = loadLevel("example.txt", maxRow, maxCol, player);
		
		for (int row = 0; row < 5; row++) {
            delete[] level[row];
        }
        delete[] level;
	}
	
	{
		int maxRow = 0;
		int maxCol = 0;
		Player player;
		char** level = loadLevel("example6.txt", maxRow, maxCol, player);

	}
	
//Test case 6 (negative row)
	{
		int maxRow = 0;
		int maxCol = 0;
		Player player;
		char** level = loadLevel("example.txt", maxRow, maxCol, player);
		
		for (int row = 0; row < 5; row++) {
            delete[] level[row];
        }
        delete[] level;
	}
	
	{
		int maxRow = 0;
		int maxCol = 0;
		Player player;
		char** level = loadLevel("example7.txt", maxRow, maxCol, player);

	}

//Test case 7 (special characters cont...)
	{
		int maxRow = 0;
		int maxCol = 0;
		Player player;
		char** level = loadLevel("example.txt", maxRow, maxCol, player);
		
		for (int row = 0; row < 5; row++) {
            delete[] level[row];
        }
        delete[] level;
	}
	
	{
		int maxRow = 0;
		int maxCol = 0;
		Player player;
		char** level = loadLevel("example8.txt", maxRow, maxCol, player);
	}

//Test case 8 (negative column?)
	{
		int maxRow = 0;
		int maxCol = 0;
		Player player;
		char** level = loadLevel("example.txt", maxRow, maxCol, player);
		
		for (int row = 0; row < 5; row++) {
            delete[] level[row];
        }
        delete[] level;
	}
	
	{
		int maxRow = 0;
		int maxCol = 0;
		Player player;
		char** level = loadLevel("example9.txt", maxRow, maxCol, player);

	}
		
//Test case 9 (missing symbol at edge)
	{
		int maxRow = 0;
		int maxCol = 0;
		Player player;
		char** level = loadLevel("example.txt", maxRow, maxCol, player);
		
		for (int row = 0; row < 5; row++) {
            delete[] level[row];
        }
        delete[] level;
	}
	
	{
		int maxRow = 0;
		int maxCol = 0;
		Player player;
		char** level = loadLevel("example10.txt", maxRow, maxCol, player);

	}

//Test case 10 (missing symbol at edge)
	{
		int maxRow = 0;
		int maxCol = 0;
		Player player;
		char** level = loadLevel("example.txt", maxRow, maxCol, player);
		
		for (int row = 0; row < 5; row++) {
            delete[] level[row];
        }
        delete[] level;
	}
	
	{
		int maxRow = 0;
		int maxCol = 0;
		Player player;
		char** level = loadLevel("example11.txt", maxRow, maxCol, player);

	}

//Test case 11 (missing symbol at edge)
	{
		int maxRow = 0;
		int maxCol = 0;
		Player player;
		char** level = loadLevel("example.txt", maxRow, maxCol, player);
		
		for (int row = 0; row < 5; row++) {
            delete[] level[row];
        }
        delete[] level;
	}
	
	{
		int maxRow = 0;
		int maxCol = 0;
		Player player;
		char** level = loadLevel("example12.txt", maxRow, maxCol, player);

	}

//Test case 12 (missing symbol at edge)
	{
		int maxRow = 0;
		int maxCol = 0;
		Player player;
		char** level = loadLevel("example.txt", maxRow, maxCol, player);
		
		for (int row = 0; row < 5; row++) {
            delete[] level[row];
        }
        delete[] level;
	}
	
	{
		int maxRow = 0;
		int maxCol = 0;
		Player player;
		char** level = loadLevel("example13.txt", maxRow, maxCol, player);

	}

//Test case 13 (missing symbol at edge)
	{
		int maxRow = 0;
		int maxCol = 0;
		Player player;
		char** level = loadLevel("example.txt", maxRow, maxCol, player);
		
		for (int row = 0; row < 5; row++) {
            delete[] level[row];
        }
        delete[] level;
	}
	
	{
		int maxRow = 0;
		int maxCol = 0;
		Player player;
		char** level = loadLevel("example14.txt", maxRow, maxCol, player);

	}

//Test case 14 (missing symbol at edge)
	{
		int maxRow = 0;
		int maxCol = 0;
		Player player;
		char** level = loadLevel("example.txt", maxRow, maxCol, player);
		
		for (int row = 0; row < 5; row++) {
            delete[] level[row];
        }
        delete[] level;
	}
	
	{
		int maxRow = 0;
		int maxCol = 0;
		Player player;
		char** level = loadLevel("example15.txt", maxRow, maxCol, player);

	}

//Test case 14 (missing symbol at edge)
	{
		int maxRow = 0;
		int maxCol = 0;
		Player player;
		char** level = loadLevel("example.txt", maxRow, maxCol, player);
		
		for (int row = 0; row < 5; row++) {
            delete[] level[row];
        }
        delete[] level;
	}
	
	{
		int maxRow = 0;
		int maxCol = 0;
		Player player;
		char** level = loadLevel("example16.txt", maxRow, maxCol, player);

	}

//Test case 14 (missing symbol at edge)
	{
		int maxRow = 0;
		int maxCol = 0;
		Player player;
		char** level = loadLevel("example.txt", maxRow, maxCol, player);
		
		for (int row = 0; row < 5; row++) {
            delete[] level[row];
        }
        delete[] level;
	}
	
	{
		int maxRow = 0;
		int maxCol = 0;
		Player player;
		char** level = loadLevel("example17.txt", maxRow, maxCol, player);

	}
	
	//Test case 3
	{
		int maxRow = 0;
		int maxCol = 0;
		Player player;
		char** level = loadLevel("example.txt", maxRow, maxCol, player);
		
		for (int row = 0; row < 5; row++) {
            delete[] level[row];
        }
        delete[] level;
	}
	
	{
		int maxRow = 0;
		int maxCol = 0;
		Player player;
		char** level = loadLevel("m", maxRow, maxCol, player);

	}


}

//unit tests for getDirection

void test_direction(){
	
	{
		char input = 'w';
		int nextRow = 1;
		int nextCol = 2;
	
		getDirection(input, nextRow, nextCol);
		
	}
	
	{
		char input = 's';
		int nextRow = 2;
		int nextCol = 1;
	
		getDirection(input, nextRow, nextCol);
		
	}
	
	{
		char input = 'a';
		int nextRow = 0;
		int nextCol = 0;
	
		getDirection(input, nextRow, nextCol);
		
	}
	
	{
		char input = 'd';
		int nextRow = 0;
		int nextCol = 0;
	
		getDirection(input, nextRow, nextCol);
		
	}
	
	{
		char input = 'q';
		int nextRow = 0;
		int nextCol = 0;
	
		getDirection(input, nextRow, nextCol);
		
	}
	
	{
		char input = 'e';
		int nextRow = 0;
		int nextCol = 0;
	
		getDirection(input, nextRow, nextCol);
		
	}
	
	
	{
		char input = '@';
		int nextRow = 1;
		int nextCol = 2;
	
		getDirection(input, nextRow, nextCol);
		
	}
	
	{
		char input = 'A';
		int nextRow = 1;
		int nextCol = 2;
	
		getDirection(input, nextRow, nextCol);
		
	}
	
	{
		char input = 'W';
		int nextRow = 1;
		int nextCol = 2;
	
		getDirection(input, nextRow, nextCol);
		
	}
	
	{
		char input = 'S';
		int nextRow = 1;
		int nextCol = 2;
	
		getDirection(input, nextRow, nextCol);
		
	}
	
	{
		char input = 'D';
		int nextRow = 1;
		int nextCol = 2;
	
		getDirection(input, nextRow, nextCol);
		
	}
	
	{
		char input = '0';
		int nextRow = 1;
		int nextCol = 2;
	
		getDirection(input, nextRow, nextCol);
		
	}
	

}



void test_delete(){
	{
		char**map = nullptr;
		int row = 0;
		deleteMap(map, row);
	}
	
	{
		
		int maxRow = 0;
		int maxCol = 0;
		Player player;
		char** level = loadLevel("example.txt", maxRow, maxCol, player);
		deleteMap(level, maxRow);

	}
	
}


//unit tests for resizeMap
void test_resize(){
	
	{
		int maxRow = 0;
		int maxCol = 0;
		Player player;
		char** map = loadLevel("example.txt", maxRow, maxCol, player);
		int row = -1;
		int col = 3;
		resizeMap(map, row, col);
		if (map){
			deleteMap(map, maxRow);
		}
	}
	
	{
		int maxRow = 0;
		int maxCol = 0;
		Player player;
		char** map = loadLevel("example.txt", maxRow, maxCol, player);
		int row = 5;
		int col = -1;
		resizeMap(map, row, col);
		if (map){
			deleteMap(map, maxRow);
		}

		
	}


//case works, getting memory leak...


	{
		int maxRow = 0;
		int maxCol = 0;
		Player player;
		char** map = loadLevel("example.txt", maxRow, maxCol, player);
		int row = 5;
		int col = 3;
		resizeMap(map, row, col);
		if (map){
			deleteMap(map, maxRow);
		}
		
	}



	
	
}

//unit tests for doPlayerMove
void test_move(){
	{
		int maxRow = 0;
		int maxCol = 0;
		Player player;
		char** map = loadLevel("example.txt", maxRow, maxCol, player);
		int nextRow = 3;
		int nextCol = 0;
		doPlayerMove(map, maxRow, maxCol, player, nextRow, nextCol);
		deleteMap(map, maxRow);
	}
	
	{
		int maxRow = 0;
		int maxCol = 0;
		Player player;
		char** map = loadLevel("example.txt", maxRow, maxCol, player);
		int nextRow = -1;
		int nextCol = 0;
		doPlayerMove(map, maxRow, maxCol, player, nextRow, nextCol);
		deleteMap(map, maxRow);
	}
	
	{
		int maxRow = 0;
		int maxCol = 0;
		Player player;
		char** map = loadLevel("example22.txt", maxRow, maxCol, player);
		int nextRow = 3;
		int nextCol = 1;
		doPlayerMove(map, maxRow, maxCol, player, nextRow, nextCol);
		deleteMap(map, maxRow);
	}
	
	{
		int maxRow = 0;
		int maxCol = 0;
		Player player;
		char** map = loadLevel("example22.txt", maxRow, maxCol, player);
		int nextRow = 3;
		int nextCol = 1;
		doPlayerMove(map, maxRow, maxCol, player, nextRow, nextCol);
		deleteMap(map, maxRow);
	}

}

void test_attack(){
	
	{
		int maxRow = 0;
		int maxCol = 0;
		Player player;
		char** map = loadLevel("example.txt", maxRow, maxCol, player);
		doMonsterAttack(map, maxRow, maxCol, player);
		deleteMap(map, maxRow);
	
	}
	
	{
		int maxRow = 0;
		int maxCol = 0;
		Player player;
		char** map = loadLevel("example19.txt", maxRow, maxCol, player);
		doMonsterAttack(map, maxRow, maxCol, player);
		deleteMap(map, maxRow);
	
	}
	
	{
		int maxRow = 0;
		int maxCol = 0;
		Player player;
		char** map = loadLevel("example21.txt", maxRow, maxCol, player);
		doMonsterAttack(map, maxRow, maxCol, player);
		deleteMap(map, maxRow);
	
	}
	
	
}






int main() {
    
    // example
    /*
    example.txt
    -----------
    5 3
    3 0
    M + -
    - + -
    - + !
    - - -
    @ - $
    */
    ////////////////////
    // this is the only code _required_ to get coverage points on part 1 (test first)
    //   invocation --> coverage
    int maxRow;
    int maxCol;
    Player player;
    char** level = loadLevel("example.txt", maxRow, maxCol, player);
    ////////////////////
    
	//calling all functions into "main" function
	test_load();
	test_direction();
	test_delete();
	test_resize();
	test_move();
	test_attack();
	
	
    ////////////////////
    // this is optional but STRONGLY recommended for preparing for part 2 (development)
    //   coverage -/-> correctness
    // note: there are _many_ ways to do this part, including ways that are more elegant and efficient than this way demonstrated here
    if (level == nullptr) {
        cout << "FAIL: level is nullptr" << endl;
    } else {
        cout << " OK : level is not nullptr" << endl;
        if (maxRow == 5) {
            cout << " OK : maxRow is 5" << endl;
        } else {
            cout << "FAIL: expected maxRow to be 5, got " << maxRow << endl; 
        }
        if (maxCol == 3) {
            cout << " OK : maxCol is 3" << endl;
        } else {
            cout << "FAIL: expected maxCol to be 3, got " << maxCol << endl; 
        }
        if (player.row == 3) {
            cout << " OK : player.row is 3" << endl;
        } else {
            cout << "FAIL: expected player.row to be 3, got " << player.row << endl; 
        }
        if (player.col == 0) {
            cout << " OK : player.col is 0" << endl;
        } else {
            cout << "FAIL: expected player.col to be 0, got " << player.col << endl; 
        }
        if (level[0][0] == 'M') {
            cout << " OK : level[0][0] is M" << endl;
        } else {
            cout << "FAIL: expected level[0][0] to be M, got " << level[0][0] << endl; 
        }
        if (level[0][1] == '+') {
            cout << " OK : level[0][1] is +" << endl;
        } else {
            cout << "FAIL: expected level[0][1] to be +, got " << level[0][1] << endl; 
        }
        if (level[0][2] == '-') {
            cout << " OK : level[0][2] is -" << endl;
        } else {
            cout << "FAIL: expected level[0][2] to be -, got " << level[0][2] << endl; 
        }
        if (level[1][0] == '-') {
            cout << " OK : level[1][0] is -" << endl;
        } else {
            cout << "FAIL: expected level[1][0] to be -, got " << level[1][0] << endl; 
        }
        if (level[1][1] == '+') {
            cout << " OK : level[1][1] is +" << endl;
        } else {
            cout << "FAIL: expected level[1][1] to be +, got " << level[1][1] << endl; 
        }
        if (level[1][2] == '-') {
            cout << " OK : level[1][2] is -" << endl;
        } else {
            cout << "FAIL: expected level[1][2] to be -, got " << level[1][2] << endl; 
        }
        if (level[2][0] == '-') {
            cout << " OK : level[2][0] is -" << endl;
        } else {
            cout << "FAIL: expected level[2][0] to be -, got " << level[2][0] << endl; 
        }
        if (level[2][1] == '+') {
            cout << " OK : level[2][1] is +" << endl;
        } else {
            cout << "FAIL: expected level[2][1] to be +, got " << level[2][1] << endl; 
        }
        if (level[2][2] == '!') {
            cout << " OK : level[2][2] is !" << endl;
        } else {
            cout << "FAIL: expected level[2][2] to be !, got " << level[2][2] << endl; 
        }
        if (level[3][0] == 'o') {
            cout << " OK : level[3][0] is o" << endl;
        } else {
            cout << "FAIL: expected level[3][0] to be o, got " << level[3][0] << endl; 
        }
        if (level[3][1] == '-') {
            cout << " OK : level[3][1] is -" << endl;
        } else {
            cout << "FAIL: expected level[3][1] to be -, got " << level[3][1] << endl; 
        }
        if (level[3][2] == '-') {
            cout << " OK : level[3][2] is -" << endl;
        } else {
            cout << "FAIL: expected level[3][2] to be -, got " << level[3][2] << endl; 
        }
        if (level[4][0] == '@') {
            cout << " OK : level[4][0] is @" << endl;
        } else {
            cout << "FAIL: expected level[4][0] to be @, got " << level[4][0] << endl; 
        }
        if (level[4][1] == '-') {
            cout << " OK : level[4][1] is -" << endl;
        } else {
            cout << "FAIL: expected level[4][1] to be -, got " << level[4][1] << endl; 
        }
        if (level[4][2] == '$') {
            cout << " OK : level[4][2] is $" << endl;
        } else {
            cout << "FAIL: expected level[4][2] to be $, got " << level[4][2] << endl; 
        }
    }
    ////////////////////
    
    ////////////////////
    // this is required to prevent memory leaks on part 1 (test first)
	
	
    if (level) {
        for (int row = 0; row < 5; row++) {
            delete[] level[row];
        }
        delete[] level;
    }
    ////////////////////
    
    return 0;
}
